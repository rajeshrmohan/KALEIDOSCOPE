<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypnotic Kaleidoscope</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            text-shadow: 0 0 8px #000;
            opacity: 0.7;
            pointer-events: none; /* Make text non-interactive */
        }
    </style>
</head>
<body>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <script>
        // --- BASIC SETUP ---
        let scene, camera, renderer;
        let kaleidoscopeContainer;
        const masterObjects = [];
        const clonedObjectGroups = [];

        // --- CONSTANTS ---
        const KALEIDO_SIDES = 6;
        const NUM_OBJECTS = 30; // Increased for a fuller screen
        const MORPH_AREA_RADIUS = 12; // Adjusted for orthographic camera
        const FRUSTUM_SIZE = 25; // Defines the visible area for the orthographic camera

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera - SWITCHED TO ORTHOGRAPHIC FOR FULL-SCREEN PATTERN
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                FRUSTUM_SIZE * aspect / -2,
                FRUSTUM_SIZE * aspect / 2,
                FRUSTUM_SIZE / 2,
                FRUSTUM_SIZE / -2,
                0.1,
                1000
            );
            camera.position.z = 10;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // --- LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xffffff, 0.8);
            pointLight1.position.set(20, 20, 20);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.6);
            pointLight2.position.set(-20, -15, 25);
            scene.add(pointLight2);

            // --- KALEIDOSCOPE STRUCTURE ---
            kaleidoscopeContainer = new THREE.Group();
            scene.add(kaleidoscopeContainer);

            // Create segments for the kaleidoscope effect
            for (let i = 0; i < KALEIDO_SIDES; i++) {
                const angle = (i / KALEIDO_SIDES) * Math.PI * 2;

                const segmentGroup = new THREE.Group();
                segmentGroup.rotation.z = angle;
                kaleidoscopeContainer.add(segmentGroup);
                clonedObjectGroups.push(segmentGroup);

                const mirroredGroup = new THREE.Group();
                mirroredGroup.rotation.z = angle;
                mirroredGroup.scale.y = -1; // Mirror across the X-Z plane
                kaleidoscopeContainer.add(mirroredGroup);
                clonedObjectGroups.push(mirroredGroup);
            }

            // --- OBJECT CREATION ---
            const geometries = [
                new THREE.IcosahedronGeometry(1.5, 0),
                new THREE.TorusKnotGeometry(1, 0.4, 64, 8),
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.TorusGeometry(2, 0.5, 16, 100),
                new THREE.OctahedronGeometry(1.8, 0)
            ];

            const masterGroup = clonedObjectGroups[0];

            for (let i = 0; i < NUM_OBJECTS; i++) {
                const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 0.7,
                    roughness: 0.2,
                });

                const object = new THREE.Mesh(geometry, material);
                
                object.position.set(
                    (Math.random() - 0.5) * MORPH_AREA_RADIUS,
                    (Math.random() - 0.5) * MORPH_AREA_RADIUS,
                    (Math.random() - 0.5) * MORPH_AREA_RADIUS
                );

                masterObjects.push(object);
                masterGroup.add(object);
                morphObject(object);
            }
            
            // Create clones for all other segments
            for (let i = 1; i < clonedObjectGroups.length; i++) {
                masterObjects.forEach(masterObj => {
                    const clone = masterObj.clone();
                    clonedObjectGroups[i].add(clone);
                });
            }

            // --- EVENT LISTENERS ---
            window.addEventListener('resize', onWindowResize, false);
        }

        function morphObject(object) {
            anime({
                targets: object.material.color,
                r: Math.random(),
                g: Math.random(),
                b: Math.random(),
                duration: anime.random(3000, 7000),
                easing: 'easeInOutSine',
            });

            anime({
                targets: object.position,
                x: (Math.random() - 0.5) * MORPH_AREA_RADIUS,
                y: (Math.random() - 0.5) * MORPH_AREA_RADIUS,
                z: (Math.random() - 0.5) * MORPH_AREA_RADIUS,
                duration: anime.random(5000, 10000),
                easing: 'easeInOutSine',
                complete: () => {
                    morphObject(object);
                }
            });

            anime({
                targets: object.rotation,
                x: Math.random() * Math.PI * 4,
                y: Math.random() * Math.PI * 4,
                z: Math.random() * Math.PI * 4,
                duration: anime.random(6000, 12000),
                easing: 'easeInOutSine'
            });

            anime({
                targets: object.scale,
                x: Math.random() * 1.5 + 0.2,
                y: Math.random() * 1.5 + 0.2,
                z: Math.random() * 1.5 + 0.2,
                duration: anime.random(5000, 10000),
                easing: 'easeInOutSine'
            });
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            // Update orthographic camera on resize
            camera.left = FRUSTUM_SIZE * aspect / -2;
            camera.right = FRUSTUM_SIZE * aspect / 2;
            camera.top = FRUSTUM_SIZE / 2;
            camera.bottom = FRUSTUM_SIZE / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- UPDATE CLONES ---
            for (let i = 1; i < clonedObjectGroups.length; i++) {
                const group = clonedObjectGroups[i];
                for (let j = 0; j < masterObjects.length; j++) {
                    const master = masterObjects[j];
                    const clone = group.children[j];
                    
                    if(clone) {
                        clone.position.copy(master.position);
                        clone.rotation.copy(master.rotation);
                        clone.scale.copy(master.scale);
                        clone.material.color.copy(master.material.color);
                    }
                }
            }

            // --- AUTOMATIC ROTATION REMOVED ---
            // The following lines were removed to prevent rotation:
            // kaleidoscopeContainer.rotation.x += 0.0003;
            // kaleidoscopeContainer.rotation.y += 0.0004;
            // kaleidoscopeContainer.rotation.z += 0.0005;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>