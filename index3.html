<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Morphing Kaleidoscope</title>
    <style>
        /* Basic CSS Reset and Setup */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
        }

        /* Canvas fills the entire screen */
        #kaleidoscopeCanvas {
            display: block;
            background-color: #000;
        }
    </style>
</head>
<body>

    <canvas id="kaleidoscopeCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('kaleidoscopeCanvas');
            const ctx = canvas.getContext('2d');

            let width, height, centerX, centerY;
            
            // --- Configuration ---
            let numSlices = 12; 
            const sliceOptions = [6, 8, 10, 12, 14, 16, 20, 24];
            let sliceIndex = 3;
            let sliceChangeTimer = 0;
            const SLICE_CHANGE_INTERVAL = 15; // Change pattern every 15 seconds

            let hue = 0; // For cycling colors
            let time = 0; // A counter for animation patterns

            // --- Setup ---
            function setup() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                centerX = width / 2;
                centerY = height / 2;
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);
            }

            // --- Event Listeners (only for window resize) ---
            window.addEventListener('resize', setup);

            // --- The Drawing Logic ---
            
            /**
             * This function draws a single segment of the pattern.
             * It will be rotated and mirrored by the main animation loop.
             */
            function drawPatternSegment() {
                // The "mouse" position is now automated using sine and cosine waves
                // with different frequencies to create complex, non-repeating paths.
                const autoX = Math.sin(time * 0.37) * (width * 0.25) + Math.cos(time * 0.21) * (width * 0.1);
                const autoY = Math.cos(time * 0.43) * (height * 0.25) + Math.sin(time * 0.19) * (height * 0.1);
                
                // Use time and the automated position to create complex, evolving shapes
                const radius = Math.sqrt(autoX*autoX + autoY*autoY);
                
                const size1 = Math.sin(time * 0.05) * 50 + radius * 0.2;
                const size2 = Math.cos(time * 0.03) * 30 + radius * 0.15;
                
                ctx.save();
                // We move the origin to the automated position within the first "slice"
                ctx.translate(autoX, autoY);
                ctx.rotate(time * 0.5);

                // Draw a few shapes
                for (let i = 0; i < 5; i++) {
                    ctx.rotate(Math.PI * 2 / 5);
                    
                    // Main shape
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size1, size1);
                    ctx.lineTo(0, size2);
                    ctx.closePath();
                    ctx.strokeStyle = `hsl(${hue + i * 10}, 80%, 60%)`;
                    ctx.lineWidth = 1 + Math.sin(time * 1.5 + i) * 2;
                    ctx.stroke();

                    // Inner shape
                    ctx.beginPath();
                    ctx.arc(size2 * 0.5, size2 * 0.5, Math.abs(size1 * 0.1), 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${hue + i * 20 + 180}, 90%, 70%, 0.5)`;
                    ctx.fill();
                }

                ctx.restore();
            }

            // --- Animation Loop ---
            function animate(timestamp) {
                // Calculate delta time for smooth animation regardless of frame rate
                const deltaTime = (timestamp - (window.lastTime || 0)) / 1000;
                window.lastTime = timestamp;

                // 1. Create the fading trail effect by drawing a semi-transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, width, height);

                // 2. The Kaleidoscope Magic!
                const angleStep = (Math.PI * 2) / numSlices;
                
                for (let i = 0; i < numSlices; i++) {
                    ctx.save();
                    
                    // Move origin to the center of the canvas
                    ctx.translate(centerX, centerY);
                    
                    // Rotate for the current slice
                    ctx.rotate(i * angleStep);
                    
                    // Draw the pattern
                    drawPatternSegment();
                    
                    // **This is the key:** Mirror the canvas for the reflection
                    ctx.scale(1, -1);
                    drawPatternSegment();
                    
                    ctx.restore();
                }

                // 3. Update animation variables
                time += deltaTime * 0.5; // Use delta time for smoother speed
                hue = (hue + 20 * deltaTime) % 360; // Use delta time for color shift

                // 4. Automatically change the number of slices periodically
                sliceChangeTimer += deltaTime;
                if (sliceChangeTimer > SLICE_CHANGE_INTERVAL) {
                    sliceChangeTimer = 0;
                    sliceIndex = (sliceIndex + 1) % sliceOptions.length;
                    numSlices = sliceOptions[sliceIndex];
                }

                // 5. Request the next frame
                requestAnimationFrame(animate);
            }

            // --- Let's Go! ---
            setup();
            animate(0); // Start the animation loop
        });
    </script>

</body>
</html>